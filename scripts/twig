#!/usr/bin/env bash
set -euo pipefail

# twig - Standalone git worktree management CLI

REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")
CONFIG_FILE="$REPO_ROOT/.dev/config.yml"

# Parse config.yml for base_dir, copy_files, and post_command
parse_config() {
  local base_dir=".worktrees/{name}"
  local post_command="claude"
  local copy_files=()

  if [ -f "$CONFIG_FILE" ]; then
    # Extract base_dir
    local config_base_dir=$(grep -E '^\s*base_dir:' "$CONFIG_FILE" | awk -F': ' '{print $2}' | tr -d '"' | xargs || echo "")
    if [ -n "$config_base_dir" ]; then
      base_dir="$config_base_dir"
    fi

    # Extract post_command
    local config_post_command=$(grep -E '^\s*post_command:' "$CONFIG_FILE" | awk -F': ' '{print $2}' | tr -d '"' | xargs || echo "")
    if [ -n "$config_post_command" ]; then
      post_command="$config_post_command"
    fi

    # Extract copy_files array
    if grep -qE '^\s*copy_files:' "$CONFIG_FILE"; then
      local in_copy_files=false
      while IFS= read -r line; do
        if echo "$line" | grep -qE '^\s*copy_files:'; then
          in_copy_files=true
          continue
        fi
        if [ "$in_copy_files" = true ]; then
          if echo "$line" | grep -qE '^\s*-\s+'; then
            local file=$(echo "$line" | sed -E 's/^\s*-\s+//' | tr -d '"' | xargs)
            copy_files+=("$file")
          else
            break
          fi
        fi
      done < "$CONFIG_FILE"
    fi
  fi

  # Environment variable overrides config
  if [ -n "${TWIG_POST_COMMAND:-}" ]; then
    post_command="$TWIG_POST_COMMAND"
  fi

  echo "$base_dir"
  echo "$post_command"
  for file in "${copy_files[@]}"; do
    echo "$file"
  done
}

# Get just the base_dir from config
get_base_dir() {
  parse_config | head -n 1
}

# Get post_command from config
get_post_command() {
  parse_config | sed -n '2p'
}

# Resolve template variables in path
resolve_path() {
  local path="$1"
  local name="$2"
  echo "$path" | sed "s/{repo}/$REPO_NAME/g; s/{name}/$name/g"
}

# Get worktree path for a name
get_worktree_path() {
  local name="$1"
  local base_dir=$(get_base_dir)
  resolve_path "$base_dir" "$name"
}

# Show usage
cmd_help() {
  cat <<EOF
twig - Git worktree management CLI

Usage:
  twig                                Interactive mode - select worktree to open
  twig go <name>                      Go to worktree and run post_command
  twig create <name>                  Create worktree + move spec from main
  twig status                         Show worktree status table
  twig path <name>                    Print worktree path (for scripts)
  twig cleanup <name> [--yes]         Remove worktree
  twig help                           Show this help

Config (.dev/config.yml):
  worktree:
    base_dir: ".worktrees/{name}"     # Worktree location
    copy_files: [.env.local]          # Files to copy
    post_command: "claude"            # Command after 'go' (or set TWIG_POST_COMMAND)

Examples:
  twig                                Interactive: pick worktree → go
  twig go my-feature                  cd to worktree + run claude (or custom command)
  twig create my-feature              Create worktree, move spec from main
  twig status                         View all worktrees with progress
  twig path my-feature                Print path only (for: cd \$(twig path x))
EOF
}

# Create worktree with spec MOVE (not copy)
cmd_create() {
  local name="$1"

  # Validate name (no special chars except hyphen/underscore)
  if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Invalid name '$name'. Use only letters, numbers, hyphens, underscores."
    exit 1
  fi

  # Parse config
  local config_output=$(parse_config)
  local base_dir=$(echo "$config_output" | head -n 1)
  local copy_files=($(echo "$config_output" | tail -n +3))

  # Resolve path
  local worktree_path=$(resolve_path "$base_dir" "$name")

  # Check if worktree already exists
  if [ -d "$worktree_path" ]; then
    echo "Error: Worktree already exists at $worktree_path"
    exit 1
  fi

  # Check if branch already exists
  if git show-ref --verify --quiet "refs/heads/feat/${name}"; then
    echo "Error: Branch 'feat/${name}' already exists"
    exit 1
  fi

  # Create worktree
  echo "Creating worktree at $worktree_path..."
  git worktree add "$worktree_path" -b "feat/${name}"

  # Copy config files
  for file in "${copy_files[@]}"; do
    if [ -f "$REPO_ROOT/$file" ]; then
      local dir=$(dirname "$file")
      mkdir -p "$worktree_path/$dir"
      cp "$REPO_ROOT/$file" "$worktree_path/$file"
      echo "Copied: $file"
    fi
  done

  # MOVE spec if exists (copy then delete from main)
  local main_spec_dir="$REPO_ROOT/.dev/specs/${name}"
  if [ -d "$main_spec_dir" ]; then
    echo "Moving spec files..."
    local wt_spec_dir="$worktree_path/.dev/specs/${name}"
    mkdir -p "$wt_spec_dir"

    local move_success=true

    if [ -f "$main_spec_dir/PLAN.md" ]; then
      if cp "$main_spec_dir/PLAN.md" "$wt_spec_dir/"; then
        echo "Moved: PLAN.md"
      else
        echo "Error: Failed to copy PLAN.md"
        move_success=false
      fi
    fi

    if [ -f "$main_spec_dir/DRAFT.md" ]; then
      if cp "$main_spec_dir/DRAFT.md" "$wt_spec_dir/"; then
        echo "Moved: DRAFT.md"
      else
        echo "Error: Failed to copy DRAFT.md"
        move_success=false
      fi
    fi

    if [ -d "$main_spec_dir/context" ]; then
      if cp -r "$main_spec_dir/context" "$wt_spec_dir/"; then
        echo "Moved: context/"
      else
        echo "Error: Failed to copy context/"
        move_success=false
      fi
    fi

    # Only delete from main if all copies succeeded
    if [ "$move_success" = true ]; then
      rm -rf "$main_spec_dir"
      echo "Removed spec from main: .dev/specs/${name}/"
    else
      echo "Warning: Spec copy had errors, keeping original in main"
    fi
  fi

  # Create .dev/local.json
  local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  mkdir -p "$worktree_path/.dev"
  cat > "$worktree_path/.dev/local.json" <<EOF
{
  "name": "${name}",
  "branch": "feat/${name}",
  "plan": ".dev/specs/${name}/PLAN.md",
  "created_at": "${timestamp}",
  "source": "main"
}
EOF

  echo ""
  echo "✅ Worktree created: $worktree_path"
  echo ""
  echo "To start working:"
  echo "  twig go ${name}"
}

# Go to worktree and run post_command
cmd_go() {
  local name="$1"
  local worktree_path=$(get_worktree_path "$name")

  if [ ! -d "$worktree_path" ]; then
    echo "Error: Worktree '$name' does not exist at $worktree_path"
    exit 1
  fi

  local post_command=$(get_post_command)

  echo "→ cd $worktree_path"
  echo "→ $post_command"
  echo ""

  cd "$worktree_path" && exec $post_command
}

# Print worktree path (for scripts)
cmd_path() {
  local name="$1"
  local worktree_path=$(get_worktree_path "$name")

  if [ ! -d "$worktree_path" ]; then
    echo "Error: Worktree '$name' does not exist at $worktree_path" >&2
    exit 1
  fi

  echo "$worktree_path"
}

# Get worktree names as array
get_worktree_names() {
  local worktrees=$(git worktree list --porcelain)
  local names=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^branch\ refs/heads/(.+)$ ]]; then
      local branch="${BASH_REMATCH[1]}"
      # Skip main branches
      if [ "$branch" != "main" ] && [ "$branch" != "master" ] && [ "$branch" != "develop" ]; then
        local name=$(echo "$branch" | sed 's|^feat/||')
        names+=("$name")
      fi
    fi
  done <<< "$worktrees"

  for name in "${names[@]}"; do
    echo "$name"
  done
}

# Show worktree status table
cmd_status() {
  # Get active sessions (24h filter)
  local state_file="$REPO_ROOT/.dev/state.local.json"
  local cutoff=$(date -u -v-24H +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -d '24 hours ago' +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "")
  local active_sessions="{}"

  if [ -f "$state_file" ] && [ -n "$cutoff" ]; then
    active_sessions=$(jq --arg cutoff "$cutoff" '
      .sessions // {} | to_entries | map(select(.value.created_at > $cutoff)) |
      group_by(.value.worktree) | map({key: .[0].value.worktree, value: length}) | from_entries
    ' "$state_file" 2>/dev/null || echo "{}")
  fi

  # Get worktree list
  local worktrees=$(git worktree list --porcelain)

  # Parse worktrees
  local current_path=""
  local current_branch=""
  local rows=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^worktree\ (.+)$ ]]; then
      current_path="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^branch\ refs/heads/(.+)$ ]]; then
      current_branch="${BASH_REMATCH[1]}"

      # Skip main branch
      if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ] || [ "$current_branch" = "develop" ]; then
        continue
      fi

      # Extract name from branch (feat/name -> name)
      local name=$(echo "$current_branch" | sed 's|^feat/||')

      # Read local.json if exists
      local plan_path=""
      if [ -f "$current_path/.dev/local.json" ]; then
        plan_path=$(jq -r '.plan // ""' "$current_path/.dev/local.json" 2>/dev/null || echo "")
      fi

      # Count TODOs in PLAN
      local total_todos=0
      local done_todos=0
      if [ -n "$plan_path" ] && [ -f "$current_path/$plan_path" ]; then
        total_todos=$(grep -cE '^\s*###\s+\[\s*\]\s+TODO' "$current_path/$plan_path" 2>/dev/null || echo 0)
        done_todos=$(grep -cE '^\s*###\s+\[x\]\s+TODO' "$current_path/$plan_path" 2>/dev/null || echo 0)
      fi

      # Progress bar
      local progress="--"
      if [ "$total_todos" -gt 0 ]; then
        local bar=""
        for i in $(seq 1 "$total_todos"); do
          if [ "$i" -le "$done_todos" ]; then
            bar="${bar}█"
          else
            bar="${bar}░"
          fi
        done
        progress="${done_todos}/${total_todos} ${bar}"
      fi

      # Git changes
      local changes=$(git -C "$current_path" status --porcelain 2>/dev/null | wc -l | xargs)

      # Behind main
      local behind=$(git -C "$current_path" rev-list --count HEAD..main 2>/dev/null || echo "?")

      # Active sessions
      local sessions=$(echo "$active_sessions" | jq -r --arg name "$name" '.[$name] // 0' 2>/dev/null || echo 0)

      # PR status (optional)
      local pr_status="-"
      if command -v gh >/dev/null 2>&1; then
        local pr_number=$(gh pr list --head "$current_branch" --json number --jq '.[0].number' 2>/dev/null || echo "")
        if [ -n "$pr_number" ]; then
          pr_status="#${pr_number}"
        fi
      fi

      rows+=("${name}|${progress}|${changes}|${behind}|${sessions}|${pr_status}")
    fi
  done <<< "$worktrees"

  # Output table
  if [ ${#rows[@]} -eq 0 ]; then
    echo "No worktrees found."
    echo ""
    echo "Create one with: twig create <name>"
    return 1
  fi

  printf "%-4s %-20s %-20s %-8s %-8s %-10s %-10s\n" "#" "NAME" "PROGRESS" "CHANGES" "BEHIND" "SESSIONS" "PR"
  printf "%-4s %-20s %-20s %-8s %-8s %-10s %-10s\n" "-" "----" "--------" "-------" "------" "--------" "--"

  local i=1
  for row in "${rows[@]}"; do
    IFS='|' read -r name progress changes behind sessions pr_status <<< "$row"
    printf "%-4s %-20s %-20s %-8s %-8s %-10s %-10s\n" "$i." "$name" "$progress" "$changes" "$behind" "$sessions" "$pr_status"
    ((i++))
  done

  return 0
}

# Interactive mode: show status then prompt for selection
cmd_interactive() {
  # Show status first
  if ! cmd_status; then
    return
  fi

  echo ""

  # Get worktree names
  local names=($(get_worktree_names))
  local count=${#names[@]}

  if [ "$count" -eq 0 ]; then
    return
  fi

  # Prompt for selection
  read -p "Select worktree [1-${count}, q to quit]: " selection

  if [ "$selection" = "q" ] || [ "$selection" = "Q" ] || [ -z "$selection" ]; then
    echo "Cancelled."
    return
  fi

  # Validate selection
  if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt "$count" ]; then
    echo "Invalid selection: $selection"
    return 1
  fi

  # Get selected name (array is 0-indexed)
  local selected_name="${names[$((selection-1))]}"

  echo ""
  cmd_go "$selected_name"
}

# Cleanup worktree
cmd_cleanup() {
  local name="$1"
  local yes_flag="${2:-}"

  local worktree_path=$(get_worktree_path "$name")

  if [ ! -d "$worktree_path" ]; then
    echo "Error: Worktree '$name' does not exist at $worktree_path"
    exit 1
  fi

  # Check for uncommitted changes
  local changes=$(git -C "$worktree_path" status --porcelain 2>/dev/null | wc -l | xargs)
  if [ "$changes" -gt 0 ]; then
    echo "Warning: Worktree has $changes uncommitted changes"
    if [ "$yes_flag" != "--yes" ]; then
      read -p "Continue with cleanup? (y/N): " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cleanup cancelled"
        exit 0
      fi
    fi
  fi

  # Remove worktree
  echo "Removing worktree: $worktree_path"
  git worktree remove "$worktree_path"

  # Ask about branch deletion
  if [ "$yes_flag" != "--yes" ]; then
    read -p "Delete branch 'feat/${name}'? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git branch -D "feat/${name}"
      echo "Branch deleted: feat/${name}"
    fi
  else
    git branch -D "feat/${name}" 2>/dev/null || true
    echo "Branch deleted: feat/${name}"
  fi

  echo "Cleanup complete"
}

# Main command router
main() {
  # No args = interactive mode
  if [ $# -eq 0 ]; then
    cmd_interactive
    exit 0
  fi

  local command="$1"
  shift

  case "$command" in
    help|--help|-h)
      cmd_help
      ;;
    create)
      if [ $# -lt 1 ]; then
        echo "Error: create requires <name>"
        exit 1
      fi
      cmd_create "$@"
      ;;
    go)
      if [ $# -lt 1 ]; then
        echo "Error: go requires <name>"
        exit 1
      fi
      cmd_go "$@"
      ;;
    path)
      if [ $# -lt 1 ]; then
        echo "Error: path requires <name>"
        exit 1
      fi
      cmd_path "$@"
      ;;
    status)
      cmd_status
      ;;
    cleanup)
      if [ $# -lt 1 ]; then
        echo "Error: cleanup requires <name>"
        exit 1
      fi
      cmd_cleanup "$@"
      ;;
    *)
      echo "Error: Unknown command '$command'"
      echo
      cmd_help
      exit 1
      ;;
  esac
}

main "$@"
